print(fUrl)
}
filterMetadata(wave = 3, source = "constructed", type = "bin")
filterMetadata <- function(new_name, varlab, old_name, type, warning, group,
q_group_N, topic1, topic2, source, respondent,
wave, scope, section, leaf, q_group_list) {
fUrl <- filterUrl
# retrieve list of parameters
paramList <- as.list(sys.call())
for (name in names(paramList)) {
cat(name, length(name))
# concatenate parameters to url
fUrl <- paste(fUrl, name, "=", paramList[name], "&", sep="")
}
print(fUrl)
}
filterMetadata(wave = 3, source = "constructed", type = "bin")
filterMetadata <- function(new_name, varlab, old_name, type, warning, group,
q_group_N, topic1, topic2, source, respondent,
wave, scope, section, leaf, q_group_list) {
fUrl <- filterUrl
# retrieve list of parameters
paramList <- as.list(match.call())
for (name in names(paramList)) {
cat(name, length(name))
# concatenate parameters to url
fUrl <- paste(fUrl, name, "=", paramList[name], "&", sep="")
}
print(fUrl)
}
filterMetadata(wave = 3, source = "constructed", type = "bin")
filterMetadata <- function(new_name, varlab, old_name, type, warning, group,
q_group_N, topic1, topic2, source, respondent,
wave, scope, section, leaf, q_group_list) {
fUrl <- filterUrl
# retrieve list of parameters
paramList <- as.list(params_from_call(match.call()))
for (name in names(paramList)) {
cat(name, length(name))
# concatenate parameters to url
fUrl <- paste(fUrl, name, "=", paramList[name], "&", sep="")
}
print(fUrl)
}
filterMetadata <- function(new_name, varlab, old_name, type, warning, group,
q_group_N, topic1, topic2, source, respondent,
wave, scope, section, leaf, q_group_list) {
fUrl <- filterUrl
# retrieve list of parameters
paramList <- as.list(params_from_call(match.call()))
for (name in names(paramList)) {
cat(name, length(name))
# concatenate parameters to url
fUrl <- paste(fUrl, name, "=", paramList[name], "&", sep="")
}
print(fUrl)
}
filterMetadata(wave = 3, source = "constructed", type = "bin")
setwd("~/Desktop/Junior Year Drive/POL 345/ffmetadata")
?match.call
params_from_call <- function(match_call) {
list <- as.list(match_call)
return(list)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
#do.call("call_api", params)
print(params)
}
searchMetadata(query = "yes")
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
return(params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
#do.call("call_api", params)
print(params)
}
searchMetadata(query = "yes")
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
searchMetadata(query = "yes")
searchMetadata(query = "yes")
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
#do.call("call_api", params)
return(params)
}
test<-searchMetadata(query = "yes")
names(test)
names(test)[2]
call_api <- function(endpoint, ...) {
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
print(baseUrl)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata(query = "yes")
call_api <- function(endpoint, ...) {
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("data1.txt"))
return(metadata)
}
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
selectMetadata <- function(new_name = NULL, field_name = NULL) {
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchTest <- searchMetadata(query = "policing", field_name = "topic1")
selectTest <- seelctMetadata(new_name = "ce3agefc", field_name = "type")
selectTest <- selectMetadata(new_name = "ce3agefc", field_name = "type")
View(selectTest)
selectTest <- selectMetadata(new_name = "ce3agefc")
View(selectTest)
filterMetadata <- function(...) {
params <- params_from_call(match.call())
print(params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
print(params)
}
filterMetadata <- function(bob = "ha")
{}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
print(params)
}
filterMetadata(bob = "ha")
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
searchTest <- searchMetadata(query = "policing", field_name = "topic1")
validNames <- c("new_name", "varlab", "old_name", "type",
"warning", "group", "q_group_N", "topic1",
"topic2", "source", "respondent", "wave",
"scope", "section", "leaf", "q_group_list",
"value1-68", "label1-68")
?cat
?stop
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params) %in% validNames)) {
stop(names(params), "not a valid variable name")
}
}
print(params)
}
filterMetadata(sandwich = "asd")
filterMetadata(sandwich = "asd", monkey =  "asdfs")
filterMetadata(type = "d", sandwich = "asd", monkey =  "asdfs")
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params), " is not a valid variable name")
}
}
print(params)
}
filterMetadata(type = "d", sandwich = "asd", monkey =  "asdfs")
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid variable name")
}
}
print(params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid variable name")
}
}
print(params)
}
filterMetadata(type = "d", sandwich = "asd", monkey =  "asdfs")
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid variable name")
}
}
do.call("call_api", params)
}
filterTest <- filterMetadata(wave = "3", source = "constructed", type = "bin")
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("data1.txt"))
return(metadata)
}
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate new_name
if (!(new_name %in% validNames)) {
stop(new_name, " is not a valid variable name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
do.call("call_api", params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid variable name")
}
}
do.call("call_api", params)
}
selectWithFieldName <- selectMetadata("ce3agefc", "type")
# php base link
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# valid variable names
validNames <- c("new_name", "varlab", "old_name", "type",
"warning", "group", "q_group_N", "topic1",
"topic2", "source", "respondent", "wave",
"scope", "section", "leaf", "q_group_list",
"value1-68", "label1-68")
selectWithFieldName <- selectMetadata("ce3agefc", "type")
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid variable name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
selectWithFieldName <- selectMetadata("ce3agefc", "type")
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid field name")
}
}
do.call("call_api", params)
}
selectWithFieldName <- selectMetadata(new_name = "ce3agefc", field_name = "type")
View(selectWithFieldName)
filterTest <- filterMetadata(type = "constructed")
View(filterTest)
filterTest <- filterMetadata(sandwich = "asdfds")
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid field name")
}
}
do.call("call_api", params)
}
# php base link
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# valid variable names
validNames <- c("new_name", "varlab", "old_name", "type",
"warning", "group", "q_group_N", "topic1",
"topic2", "source", "respondent", "wave",
"scope", "section", "leaf", "q_group_list",
"value1-68", "label1-68")
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("data1.txt"))
return(metadata)
}
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
filterTest <- filterMetadata(not_name = "asdfsd")
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid field name")
}
}
do.call("call_api", params)
}
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("data1.txt"))
return(metadata)
}
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
# php base link
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# valid variable names
validNames <- c("new_name", "varlab", "old_name", "type",
"warning", "group", "q_group_N", "topic1",
"topic2", "source", "respondent", "wave",
"scope", "section", "leaf", "q_group_list",
"value1-68", "label1-68")
filterTest <- filterMetadata(not_name = "asdfsd")
filterTest <- filterMetadata(wave = "3", type = "bin")
filterTest <- filterMetadata(wave = "3", type = "bin")
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("json_temp.txt"))
return(metadata)
}
filterTest <- filterMetadata(wave = "3", type = "bin")
filterTest <- filterMetadata(wave = "3", type = "bin")
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "json_temp.txt")
metadata <- jsonlite::stream_in(file("json_temp.txt"))
return(metadata)
}
filterTest <- filterMetadata(wave = "3", type = "bin")
View(filterTest)
