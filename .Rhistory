names(params)[1] <- "endpoint"
return(params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
#do.call("call_api", params)
print(params)
}
searchMetadata(query = "yes")
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
searchMetadata(query = "yes")
searchMetadata(query = "yes")
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
#do.call("call_api", params)
return(params)
}
test<-searchMetadata(query = "yes")
names(test)
names(test)[2]
call_api <- function(endpoint, ...) {
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
print(baseUrl)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata(query = "yes")
call_api <- function(endpoint, ...) {
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("data1.txt"))
return(metadata)
}
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
selectMetadata <- function(new_name = NULL, field_name = NULL) {
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchTest <- searchMetadata(query = "policing", field_name = "topic1")
selectTest <- seelctMetadata(new_name = "ce3agefc", field_name = "type")
selectTest <- selectMetadata(new_name = "ce3agefc", field_name = "type")
View(selectTest)
selectTest <- selectMetadata(new_name = "ce3agefc")
View(selectTest)
filterMetadata <- function(...) {
params <- params_from_call(match.call())
print(params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
print(params)
}
filterMetadata <- function(bob = "ha")
{}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
print(params)
}
filterMetadata(bob = "ha")
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
searchTest <- searchMetadata(query = "policing", field_name = "topic1")
validNames <- c("new_name", "varlab", "old_name", "type",
"warning", "group", "q_group_N", "topic1",
"topic2", "source", "respondent", "wave",
"scope", "section", "leaf", "q_group_list",
"value1-68", "label1-68")
?cat
?stop
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params) %in% validNames)) {
stop(names(params), "not a valid variable name")
}
}
print(params)
}
filterMetadata(sandwich = "asd")
filterMetadata(sandwich = "asd", monkey =  "asdfs")
filterMetadata(type = "d", sandwich = "asd", monkey =  "asdfs")
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params), " is not a valid variable name")
}
}
print(params)
}
filterMetadata(type = "d", sandwich = "asd", monkey =  "asdfs")
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid variable name")
}
}
print(params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid variable name")
}
}
print(params)
}
filterMetadata(type = "d", sandwich = "asd", monkey =  "asdfs")
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid variable name")
}
}
do.call("call_api", params)
}
filterTest <- filterMetadata(wave = "3", source = "constructed", type = "bin")
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("data1.txt"))
return(metadata)
}
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate new_name
if (!(new_name %in% validNames)) {
stop(new_name, " is not a valid variable name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
params <- params_from_call(match.call())
do.call("call_api", params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid variable name")
}
}
do.call("call_api", params)
}
selectWithFieldName <- selectMetadata("ce3agefc", "type")
# php base link
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# valid variable names
validNames <- c("new_name", "varlab", "old_name", "type",
"warning", "group", "q_group_N", "topic1",
"topic2", "source", "respondent", "wave",
"scope", "section", "leaf", "q_group_list",
"value1-68", "label1-68")
selectWithFieldName <- selectMetadata("ce3agefc", "type")
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid variable name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
selectWithFieldName <- selectMetadata("ce3agefc", "type")
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid field name")
}
}
do.call("call_api", params)
}
selectWithFieldName <- selectMetadata(new_name = "ce3agefc", field_name = "type")
View(selectWithFieldName)
filterTest <- filterMetadata(type = "constructed")
View(filterTest)
filterTest <- filterMetadata(sandwich = "asdfds")
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid field name")
}
}
do.call("call_api", params)
}
# php base link
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# valid variable names
validNames <- c("new_name", "varlab", "old_name", "type",
"warning", "group", "q_group_N", "topic1",
"topic2", "source", "respondent", "wave",
"scope", "section", "leaf", "q_group_list",
"value1-68", "label1-68")
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("data1.txt"))
return(metadata)
}
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
filterTest <- filterMetadata(not_name = "asdfsd")
selectMetadata <- function(new_name = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
searchMetadata <- function(query = NULL, field_name = NULL) {
# validate field_name
if (!(field_name %in% validNames)) {
stop(field_name, " is not a valid field name")
}
params <- params_from_call(match.call())
do.call("call_api", params)
}
filterMetadata <- function(...) {
params <- params_from_call(match.call())
# validate parameters, ignoring the first entry (the function name)
for (i in 2:length(params)) {
if (!(names(params)[i] %in% validNames)) {
stop(names(params)[i], " is not a valid field name")
}
}
do.call("call_api", params)
}
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("data1.txt"))
return(metadata)
}
params_from_call <- function(match_call) {
params <- as.list(match_call)
# rename first element in order for call_api to recognize params
names(params)[1] <- "endpoint"
# convert first parameter to character type
params[1] <- as.character(params[1])
return(params)
}
# php base link
baseUrl <- "http://mayap.mycpanel.princeton.edu/"
# valid variable names
validNames <- c("new_name", "varlab", "old_name", "type",
"warning", "group", "q_group_N", "topic1",
"topic2", "source", "respondent", "wave",
"scope", "section", "leaf", "q_group_list",
"value1-68", "label1-68")
filterTest <- filterMetadata(not_name = "asdfsd")
filterTest <- filterMetadata(wave = "3", type = "bin")
filterTest <- filterMetadata(wave = "3", type = "bin")
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "data1.txt")
metadata <- jsonlite::stream_in(file("json_temp.txt"))
return(metadata)
}
filterTest <- filterMetadata(wave = "3", type = "bin")
filterTest <- filterMetadata(wave = "3", type = "bin")
call_api <- function(endpoint, ...) {
# create link based on specified endpoint
baseUrl <- paste(baseUrl, endpoint, ".php?", sep = "")
# retrieve and iterate through params
params <- list(...)
for (i in 1:length(params)) {
baseUrl <- paste(baseUrl, names(params)[i], "=", params[i], "&",
sep = "")
}
# problem with JSON objects not being separated by new line characters
# inefficient workaround
lines <- readLines(baseUrl)
m <- gregexpr("}", lines, perl = TRUE)
# add new line after each matched instance of "}"
regmatches(lines, m) <- "}\n"
# write to file and then read to file (inefficient)
write(lines, "json_temp.txt")
metadata <- jsonlite::stream_in(file("json_temp.txt"))
return(metadata)
}
filterTest <- filterMetadata(wave = "3", type = "bin")
View(filterTest)
roxygen2::document()
library(devtools)
library(roxygen2)
document()
setwd("..")
install("ffmetadata")
?select_metadata
?filter_metadata
setwd("~/Desktop/Junior Year Drive/ffmetadata")
library(devtools)
library(roxygen2)
document()
?filter_metadata
document()
?filter_metadata
document()
?filter_metadata
warnings()
document()
?filter_metadata
select1 <- select_metadata(variable_name = "ce3agefc")
View(select1)
document()
?select_metadata
?search_metadata
?filter_metadata
document()
?filter_metadata
?filter_metadata
setwd("~/Desktop/Junior Year Drive/Spring/POL346/Reports/Report 1")
report <- read.csv("report.csv")
View(report)
library(devtools)
library(roxygen2)
document()
?select_metadata
select_type <- select_metadata(variable_name = "ce3agefc", field_name = "type")
select_entire <- select_metadata(variable_name = "ce3agefc")
library(ffmetadata)
select_type <- select_metadata(variable_name = "ce3agefc", field_name = "type")
select_type <- select_metadata(variable_name = "ce3datey", field_name = "source")
select_entire <- select_metadata(variable_name = "ce3datey")
View(select_entire)
search_topic1 <- search_metadata(query = "health", field_name = "topic1")
search_topic1 <- search_metadata(query = "mental health", field_name = "topic1")
search_topic1 <- search_metadata(query = "mental_health", field_name = "topic1")
search_topic1 <- search_metadata(query = "health", field_name = "topic1")
search_topic1 <- search_metadata(query = "policing", field_name = "topic1")
View(search_topic1)
search_topic1 <- search_metadata(query = "jail", field_name = "varlab")
search_topic1 <- search_metadata(query = "health", field_name = "topic1")
debug(search_metadata)
search_topic1 <- search_metadata(query = "health", field_name = "topic1")
search_topic1 <- search_metadata(query = "health", field_name = "topic1")
base_url
lines
b
# named-list approach
params_list <- c("bin", "questionnaire", 20)
names(params_list) <- c("type", "source", "scope")
# call to filter_metadata
filtered <- filter_metadata(params_list)
base_url
filtered <- filter_metadata(type="bin",source="questionnaire",scope=20)
list <- c(3, "constructed")
names(list) <- c("wave", "source")
filtered <- filter_metadata(list, type = "bin")
search_topic1 <- search_metadata(query = "health", field_name = "topic1")
filtered <- filter_metadata(list, type = "bin")
params_list <- c("bin", "questionnaire", 20)
names(params_list) <- c("type", "source", "scope")
# call to filter_metadata
filtered <- filter_metadata(params_list)
